package threadsAssignment;

// Importing Required Libraries
import java.util.Random;
import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

// Creating A class For User Defined Exception to Exit the threads
class ExitException extends Exception{
	private static final long serialVersionUID = 1L;
}


public class EditBufferClass {
        //Buffer of Size 5
	private static ListDataStructure list = new ListDataStructure(5);
    private static int val;
        // ReEterent Lock for Synchronization between multiple Producer threads and multiple consumer threads
    private static Lock lock1 = new ReentrantLock();
        // Declarations Of Semaphores for Full and Empty with permits as 5 
    private static Semaphore full = new Semaphore(5);
    private static Semaphore empty = new Semaphore(5);
        // Mutex lock for synchronization between producer and consumer
    private static Object lock = new Object();

        // Method for Inserting Data into the buffer
        public static void insertData() throws ExitException, InterruptedException{
        // Creating an Object for Random to Create Random Numbers	
    	    Random random = new Random();
      	    int insertval=0;
      	    while(true){
               // Sleeping for random amount of time ranging from 0 to 999 Milliseconds 
       		   Thread.sleep(random.nextInt(1000));
    	     	   try {
    	     		   //Acquiring a permit ie., decreasing the number of permits of semaphore full by 1 
						full.acquire();
					}catch (InterruptedException e) {
						//Throwing a User Exception to exit from the thread it is invoked when interrupted 
						// by ShutdownNow method of Executor Service
						throw new ExitException();
						}
    	     	   //Synchronized block - It runs with sync with the remove data synchronized block  
                   //Used for concurrency control
    	     	   synchronized (lock) {
    	     		   //lock1.lock locks the next thread which runs the method
     	    	   		lock1.lock();
    	    			insertval=random.nextInt(100);
    	    		   //Adding a random value in range 0 to 99 into the list
        	    	    list.add(insertval);
           	        }
    	    		System.out.println(" Producer has produced: "+insertval);
    	    		//Releasing a permit ie., increasing the number of permits of semaphore empty by 1
    	    	    empty.release();
    	    	    //lock1.unlock unlocks the lock generated by the previous thread
    	    	    lock1.unlock();
           	 }	
        }
       
        //Method for Removing data from the buffer
        public static void removeData() throws ExitException, InterruptedException {
     	    while(true){ 
     	 	    // Creating an Object for Random to Create Random Numbers	 
     	   	    Random random = new Random(); 
                // Sleeping for random amount of time ranging from 0 to 1999 Milliseconds
     		    Thread.sleep(random.nextInt(2000));
     		    try {
     		    //Acquiring a permit ie., decreasing the number of permits of semaphore empty by 1
                    empty.acquire(); 
                    }catch (InterruptedException e) {
                //Throwing a User Exception to exit from the thread it is invoked when interrupted 
	    	    // by ShutdownNow method of Executor Service
	                     throw new ExitException();        	      
                    }
     		    //Synchronized block - It runs with sync with the insert data synchronized block  
                //Used for concurrency control
	     	        synchronized (lock){
	     	            //lock1.lock locks the next thread which runs the method	   
	     	    	    lock1.lock();
	     	            //Removing the first entered value from the list
	            	    val = list.remove();
    	            } 
        	    //Releasing a permit ie., increasing the number of permits of semaphore empty by 1
       		    full.release();
       		    System.out.println(" Consumer has consumed: "+val);
	    	    //lock1.unlock unlocks the lock generated by the previous thread
       		    lock1.unlock();
    	        } 
           }    
        
}